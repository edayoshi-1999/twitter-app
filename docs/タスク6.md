# タスク6: 最初のTDDサイクル（ツイート投稿機能）

## 📋 このタスクで学ぶこと

- **TDD（テスト駆動開発）** の基本サイクル「Red → Green → Refactor」を体験する
- **失敗するテストを先に書く** という開発手法を実践する
- Laravel の **フィーチャーテスト**、**FormRequest**、**Controller** の書き方を学ぶ
- テストが「品質の保証」になることを実感する

---

## 🎯 タスクの目的

**「ツイート投稿機能」を TDD で実装する**

ユーザーがツイートを投稿できる API エンドポイント `POST /api/tweets` を作ります。

### 完成イメージ

```
【ユーザーの操作】
1. ログインする
2. ツイート本文を入力する（最大280文字）
3. 「投稿」ボタンを押す

【システムの動作】
1. ツイート本文が有効かチェックする
2. データベースに保存する
3. 作成されたツイートを返す
```

---

## 🔄 TDD サイクルとは？

TDD（Test Driven Development）は、**「テストを先に書いてから実装する」** 開発手法です。

### Red → Green → Refactor の流れ

```
┌─────────────────────────────────────────────┐
│  🔴 Red（レッド）                            │
│  失敗するテストを書く                        │
│  「こういう動きをしてほしい」を書く          │
└──────────────┬──────────────────────────────┘
               ↓
┌──────────────────────────────────────────────┐
│  🟢 Green（グリーン）                         │
│  テストを通す最小限の実装をする              │
│  「とにかくテストを通す」ことに集中          │
└──────────────┬───────────────────────────────┘
               ↓
┌──────────────────────────────────────────────┐
│  🔵 Refactor（リファクタリング）              │
│  コードをきれいにする                        │
│  テストが通ったまま、品質を上げる            │
└──────────────┬───────────────────────────────┘
               ↓
              次の機能へ（繰り返し）
```

### なぜテストを先に書くの？

| 理由 | 説明 |
|------|------|
| **1. 仕様を明確にできる** | 「何を作るか」をテストで表現するので、仕様がぶれない |
| **2. バグを早期発見できる** | 実装中に即座にテストが失敗するので、すぐに気づける |
| **3. リファクタリングが安全** | テストがあるので、コード改善時も安心 |
| **4. ドキュメントになる** | テストコードが「仕様書」の役割を果たす |

---

## 📝 実施内容（3ステップ）

### ステップ1: 🔴 Red（失敗するテストを書く）

#### やること

**「こうあるべき」という仕様をテストコードで書く**

#### 作成するファイル

```
backend/tests/Feature/Tweet/TweetTest.php
```

#### テストケース（4つ）

| # | テスト内容 | 期待する結果 |
|---|-----------|-------------|
| 1 | 認証されていないユーザーがツイート投稿 | **401エラー**（認証が必要） |
| 2 | 認証済みユーザーがツイート投稿 | **201成功**（ツイートが作成される） |
| 3 | ツイート本文が空 | **422エラー**（バリデーションエラー） |
| 4 | ツイート本文が280文字を超える | **422エラー**（バリデーションエラー） |

#### テストコード例

```php
<?php

// tests/Feature/Tweet/TweetTest.php

use App\Models\User;

it('認証されていないユーザーはツイートを投稿できない', function () {
    // ログインせずにツイート投稿をリクエスト
    $response = $this->postJson('/api/tweets', [
        'body' => 'これはテストツイートです',
    ]);

    // 401エラーが返ることを確認
    $response->assertStatus(401);
});

it('認証済みユーザーはツイートを投稿できる', function () {
    // テスト用ユーザーを作成してログイン
    $user = User::factory()->create();

    // ログイン状態でツイート投稿をリクエスト
    $response = $this->actingAs($user)->postJson('/api/tweets', [
        'body' => 'これはテストツイートです',
    ]);

    // 201（Created）が返ることを確認
    $response->assertStatus(201)
        ->assertJsonStructure(['id', 'body', 'user', 'created_at']);

    // データベースに保存されたことを確認
    $this->assertDatabaseHas('tweets', [
        'body' => 'これはテストツイートです',
        'user_id' => $user->id,
    ]);
});

it('ツイート本文が空の場合バリデーションエラーが返る', function () {
    $user = User::factory()->create();

    // 空の本文でリクエスト
    $response = $this->actingAs($user)->postJson('/api/tweets', [
        'body' => '',
    ]);

    // 422（バリデーションエラー）が返ることを確認
    $response->assertStatus(422)
        ->assertJsonValidationErrors(['body']);
});

it('ツイート本文が280文字を超える場合バリデーションエラーが返る', function () {
    $user = User::factory()->create();

    // 281文字の本文でリクエスト
    $response = $this->actingAs($user)->postJson('/api/tweets', [
        'body' => str_repeat('あ', 281),
    ]);

    // 422（バリデーションエラー）が返ることを確認
    $response->assertStatus(422)
        ->assertJsonValidationErrors(['body']);
});
```

#### テストを実行する

```bash
cd backend
composer test

# または
./vendor/bin/pest
```

#### 期待される結果

```
❌ すべてのテストが失敗する

理由:
- ルート /api/tweets が存在しない
- コントローラーが存在しない
- マイグレーションが実行されていない
```

**これが正常です！** テストを先に書くので、最初は失敗して当然です。

---

### ステップ2: 🟢 Green（テストを通す最小限の実装）

#### やること

**テストを通すために必要な最小限のコードを書く**

#### 実装の流れ

```
1. マイグレーション実行
   ↓
2. FormRequest 作成（バリデーション）
   ↓
3. Controller 作成（ビジネスロジック）
   ↓
4. ルート定義
   ↓
5. テスト実行 → 成功確認
```

---

#### 2-1. マイグレーション実行

```bash
cd backend

# データベースのマイグレーション実行
php artisan migrate

# テスト用データベースのマイグレーション実行
php artisan migrate --env=testing
```

**実行されるマイグレーション:**
- `users` テーブル（タスク3で作成済み）
- `tweets` テーブル（タスク3で作成済み）

**確認方法:**

```bash
# テーブルが作成されたか確認
php artisan db:show
php artisan db:table users
php artisan db:table tweets
```

---

#### 2-2. FormRequest の作成

**FormRequest とは？**

> Laravel の機能で、**バリデーション（入力値の検証）を分離する仕組み**です。
> コントローラーが肥大化するのを防ぎます。

```bash
# FormRequest を作成
php artisan make:request StoreTweetRequest
```

**作成されるファイル:** `app/Http/Requests/StoreTweetRequest.php`

**実装内容:**

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreTweetRequest extends FormRequest
{
    /**
     * このリクエストを実行する権限があるか判定
     */
    public function authorize(): bool
    {
        // ログインしているユーザーのみ許可
        return $this->user() !== null;
    }

    /**
     * バリデーションルール
     */
    public function rules(): array
    {
        return [
            'body' => ['required', 'string', 'max:280'],
        ];
    }

    /**
     * バリデーションエラーメッセージ（オプション）
     */
    public function messages(): array
    {
        return [
            'body.required' => 'ツイート本文は必須です。',
            'body.max' => 'ツイート本文は280文字以内で入力してください。',
        ];
    }
}
```

**ポイント:**

| メソッド | 役割 |
|---------|------|
| `authorize()` | リクエストを実行する権限があるかチェック |
| `rules()` | バリデーションルールを定義 |
| `messages()` | エラーメッセージをカスタマイズ（オプション） |

---

#### 2-3. TweetController の作成

**Controller とは？**

> **リクエストを受け取り、レスポンスを返す役割**を持つクラスです。
> Laravel の MVC パターンの「C（Controller）」です。

```bash
# コントローラーを作成
php artisan make:controller TweetController
```

**作成されるファイル:** `app/Http/Controllers/TweetController.php`

**実装内容:**

```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreTweetRequest;
use App\Models\Tweet;
use Illuminate\Http\JsonResponse;

class TweetController extends Controller
{
    /**
     * ツイートを投稿する
     *
     * @param StoreTweetRequest $request
     * @return JsonResponse
     */
    public function store(StoreTweetRequest $request): JsonResponse
    {
        // 1. ツイートを作成
        $tweet = Tweet::create([
            'body' => $request->input('body'),
            'user_id' => $request->user()->id,
        ]);

        // 2. ツイートをリロード（リレーションを取得するため）
        $tweet->load('user');

        // 3. JSONレスポンスを返す（201 Created）
        return response()->json([
            'id' => $tweet->id,
            'body' => $tweet->body,
            'user' => [
                'id' => $tweet->user->id,
                'name' => $tweet->user->name,
            ],
            'created_at' => $tweet->created_at->toIso8601String(),
        ], 201);
    }
}
```

**ポイント:**

1. **`StoreTweetRequest $request`** を引数にすることで、自動的にバリデーションが実行される
2. **`$request->user()`** でログイン中のユーザー情報を取得
3. **`Tweet::create()`** でデータベースに保存
4. **`response()->json(..., 201)`** で JSON レスポンスを返す

---

#### 2-4. ルート定義

**Route とは？**

> **URL と Controller を紐付ける設定**です。
> 「どの URL にアクセスしたら、どの Controller が動くか」を決めます。

**ファイル:** `routes/api.php`

**追加する内容:**

```php
<?php

use App\Http\Controllers\TweetController;
use Illuminate\Support\Facades\Route;

// ツイート投稿エンドポイント
Route::post('/tweets', [TweetController::class, 'store'])
    ->middleware('auth:sanctum');
```

**ポイント:**

- `POST /api/tweets` にアクセスすると `TweetController@store` が実行される
- `->middleware('auth:sanctum')` で認証チェック（ログインしていないと401エラー）

---

#### 2-5. テスト実行 → 成功確認

```bash
cd backend
composer test

# または
./vendor/bin/pest
```

**期待される結果:**

```
✅ すべてのテストが成功する

PASS  Tests\Feature\Tweet\TweetTest
✓ 認証されていないユーザーはツイートを投稿できない
✓ 認証済みユーザーはツイートを投稿できる
✓ ツイート本文が空の場合バリデーションエラーが返る
✓ ツイート本文が280文字を超える場合バリデーションエラーが返る

Tests:  4 passed
Time:   0.5s
```

**成功したら、ステップ3へ進みます！**

---

### ステップ3: 🔵 Refactor（リファクタリング）

#### やること

**テストが通った状態で、コードをきれいにする**

#### リファクタリングのチェックリスト

| # | チェック項目 | 確認内容 |
|---|-------------|---------|
| 1 | **コントローラーが薄いか？** | ビジネスロジックがコントローラーに混在していないか |
| 2 | **重複コードはないか？** | テストコードで同じ処理が繰り返されていないか |
| 3 | **変数名・メソッド名が明確か？** | 誰が見ても理解できる名前になっているか |
| 4 | **マジックナンバーはないか？** | `280` などの数値を定数化すべきか |

#### リファクタリング例1: マジックナンバーの定数化

**Before（リファクタリング前）:**

```php
public function rules(): array
{
    return [
        'body' => ['required', 'string', 'max:280'],
    ];
}
```

**After（リファクタリング後）:**

```php
class StoreTweetRequest extends FormRequest
{
    private const MAX_TWEET_LENGTH = 280;

    public function rules(): array
    {
        return [
            'body' => ['required', 'string', 'max:' . self::MAX_TWEET_LENGTH],
        ];
    }
}
```

#### リファクタリング例2: テストコードの重複削減

**Before（リファクタリング前）:**

```php
it('認証済みユーザーはツイートを投稿できる', function () {
    $user = User::factory()->create();
    $response = $this->actingAs($user)->postJson('/api/tweets', [
        'body' => 'これはテストツイートです',
    ]);
    // ...
});

it('ツイート本文が空の場合バリデーションエラーが返る', function () {
    $user = User::factory()->create(); // 重複
    $response = $this->actingAs($user)->postJson('/api/tweets', [
        'body' => '',
    ]);
    // ...
});
```

**After（リファクタリング後）:**

```php
// ヘルパー関数を定義
function createAuthenticatedUser(): User
{
    return User::factory()->create();
}

it('認証済みユーザーはツイートを投稿できる', function () {
    $user = createAuthenticatedUser();
    $response = $this->actingAs($user)->postJson('/api/tweets', [
        'body' => 'これはテストツイートです',
    ]);
    // ...
});

it('ツイート本文が空の場合バリデーションエラーが返る', function () {
    $user = createAuthenticatedUser(); // すっきり
    $response = $this->actingAs($user)->postJson('/api/tweets', [
        'body' => '',
    ]);
    // ...
});
```

#### リファクタリング後のテスト実行

```bash
composer test
```

**重要:** リファクタリング後もテストが通ることを確認してください。

---

## 📊 成果物

### 作成されるファイル

| # | ファイルパス | 説明 |
|---|------------|------|
| 1 | `tests/Feature/Tweet/TweetTest.php` | フィーチャーテスト（4つのテストケース） |
| 2 | `app/Http/Requests/StoreTweetRequest.php` | バリデーションロジック |
| 3 | `app/Http/Controllers/TweetController.php` | コントローラー（store メソッド） |
| 4 | `routes/api.php` | ルート定義（更新） |

### 実行されるマイグレーション

- `users` テーブル
- `tweets` テーブル

---

## ⚠️ よくある質問と注意点

### Q1: テストが失敗する...

**よくある原因:**

| エラー内容 | 原因 | 解決方法 |
|-----------|------|---------|
| `Route [api/tweets] not defined` | ルート定義忘れ | `routes/api.php` を確認 |
| `Class 'TweetController' not found` | コントローラー作成忘れ | `php artisan make:controller TweetController` |
| `SQLSTATE[42S02]: Base table or view not found` | マイグレーション未実行 | `php artisan migrate --env=testing` |
| `Unauthenticated` | 認証エラー | テストで `actingAs($user)` を使っているか確認 |

**デバッグ方法:**

```bash
# エラーの詳細を表示
./vendor/bin/pest --verbose

# 特定のテストのみ実行
./vendor/bin/pest --filter="認証済みユーザーはツイートを投稿できる"
```

---

### Q2: `actingAs($user)` って何？

**説明:**

> Laravel のテストヘルパーメソッドで、**「このユーザーでログインした状態にする」** という意味です。

```php
$user = User::factory()->create(); // テスト用ユーザーを作成
$this->actingAs($user); // このユーザーでログイン状態にする
```

これにより、`$request->user()` で認証済みユーザー情報が取得できます。

---

### Q3: `assertStatus(201)` の数字の意味は？

**HTTP ステータスコード:**

| コード | 意味 | 用途 |
|-------|------|------|
| 200 | OK | 正常に処理された |
| 201 | Created | リソースが作成された |
| 401 | Unauthorized | 認証が必要 |
| 403 | Forbidden | 権限がない |
| 422 | Unprocessable Entity | バリデーションエラー |
| 500 | Internal Server Error | サーバーエラー |

ツイート投稿は「新しいリソース（ツイート）を作成する」ので、**201** を返します。

---

### Q4: DDD（ドメイン駆動設計）はどこ？

**このタスクでは、まだ本格的なDDDは導入していません。**

#### 段階的な適用

```
タスク6（今回）: シンプルな実装
  ↓ Controller + Model + FormRequest

タスク7以降: DDD本格導入
  ↓ UseCase, Repository, Entity, Value Object
```

CLAUDE.md にも記載されています：

> 最初は簡易的なDDD（Service + Repository パターン）
> 複雑性が増すにつれて、Entity/Value Object を分離

**理由:**

1. まずは TDD のサイクルを体得する
2. シンプルな実装で動作を確認する
3. 次のタスクで徐々に洗練させる

---

## ✅ タスク完了の条件

このタスクが完了したと言える条件：

- [ ] フィーチャーテスト（4つ）がすべて成功する
- [ ] マイグレーションが正常に実行されている
- [ ] `POST /api/tweets` エンドポイントが動作する
- [ ] コードがLaravelのベストプラクティスに従っている
- [ ] すべての変更がコミットされている
- [ ] ブランチに push されている

### 確認方法

```bash
# 1. テストが通るか確認
cd backend
composer test

# 2. マイグレーション確認
php artisan migrate:status

# 3. ルート確認
php artisan route:list --path=tweets

# 4. コードスタイル確認（Laravel Pint）
./vendor/bin/pint --test

# 5. Git の状態確認
git status
```

---

## 🎓 学んだこと（まとめ）

### 技術的なこと

- ✅ TDD の「Red → Green → Refactor」サイクル
- ✅ Laravel の **Pest** によるテスト駆動開発
- ✅ **FormRequest** によるバリデーション分離
- ✅ **Controller** の責務（薄く保つ）
- ✅ **Route** の定義と認証ミドルウェア

### 考え方

- ✅ **テストファースト** の重要性
  - 実装前に「期待する動き」を明確にする
  - バグを早期発見できる

- ✅ **小さく作る** ことの価値
  - 一度に全部作らない
  - 1つの機能に集中する

- ✅ **リファクタリング** の安全性
  - テストがあれば安心してコード改善できる

---

## 🚀 次のタスクへ

タスク6が完了したら、次は **タスク7: Laravel Sanctum 認証の導入** に進みます。

現在の認証は簡易的なものなので、本格的な認証機能を実装します。

---

## 📚 参考リソース

### Laravel 公式ドキュメント

- [Testing: Getting Started](https://laravel.com/docs/11.x/testing)
- [HTTP Tests](https://laravel.com/docs/11.x/http-tests)
- [Validation](https://laravel.com/docs/11.x/validation)
- [Controllers](https://laravel.com/docs/11.x/controllers)

### Pest 公式ドキュメント

- [Pest - An elegant PHP Testing Framework](https://pestphp.com)
- [Writing Tests](https://pestphp.com/docs/writing-tests)
- [Expectations](https://pestphp.com/docs/expectations)

### TDD 関連書籍

- [Test Driven Development: By Example - Kent Beck](https://www.amazon.com/dp/0321146530)
- [テスト駆動開発](https://www.amazon.co.jp/dp/4274217884)

---

**最終更新日**: 2025-11-16
**担当**: Claude（AIアシスタント）
**レビュー**: 新人エンジニア向けに最適化済み
